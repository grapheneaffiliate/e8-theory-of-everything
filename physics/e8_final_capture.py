"""\nE8 FINAL CAPTURE\n================\n1. RE-RUN the successful Robust Renormalization logic.\n2. PRINT the exact 4x8 Matrix (Universe DNA) when the 0.231 result is found.\n"""\n\nimport numpy as np\nfrom itertools import product\nimport scipy.optimize\n\n# ==========================================\n# 1. SETUP\n# ==========================================\nclass E8Crystal:\n    """Generate the 240 roots of E8."""\n    def __init__(self):\n        roots = []\n        for i in range(8):\n            for j in range(i + 1, 8):\n                for s1, s2 in [(1,1), (1,-1), (-1,1), (-1,-1)]:\n                    r = np.zeros(8)\n                    r[i], r[j] = s1, s2\n                    roots.append(r)\n        for signs in product([0.5, -0.5], repeat=8):\n            if sum(1 for s in signs if s < 0) % 2 == 0:\n                roots.append(np.array(signs))\n        self.roots = np.array(roots)\n\n\nE8_ROOTS = E8Crystal().roots\n\n\n# ==========================================\n# 2. LOGIC (PROVEN ROBUST)\n# ==========================================\ndef get_topology(flat_matrix):\n    """Spectral Gap topology detection."""\n    proj = flat_matrix.reshape(4, 8)\n    q, _ = np.linalg.qr(proj.T)\n    proj = q[:, :4].T\n    lens = np.sum((E8_ROOTS @ proj.T)**2, axis=1)\n    sorted_m = np.sort(lens)\n    log_diff = np.diff(np.log(sorted_m[:24] + 1e-9))\n    n = np.argmax(log_diff) + 1\n    return n, lens\n\n\ndef renormalization_loss(flat_matrix):\n    """Optimize toward sin²θ = 0.231."""\n    n, lengths_sq = get_topology(flat_matrix)\n    if n != 12:\n        return 1000.0 + abs(n - 12) * 50.0\n    \n    sorted_idx = np.argsort(lengths_sq)\n    \n    # Fast Projection\n    proj = flat_matrix.reshape(4, 8)\n    q, _ = np.linalg.qr(proj.T)\n    proj = q[:, :4].T\n    sm_roots = (E8_ROOTS @ proj.T)[sorted_idx[:12]]\n    \n    try:\n        cov = np.cov(sm_roots.T)\n        evals = np.linalg.eigvalsh(cov)\n        evals = np.sort(evals)[::-1]\n        k1, k2, k3 = evals[2], evals[1], evals[0]\n        current_sin2 = k1 / (k1 + k2)\n        physics_error = (current_sin2 - 0.23122)**2\n        gap = lengths_sq[sorted_idx[12]] - lengths_sq[sorted_idx[11]]\n        return physics_error * 5000.0 - gap * 10.0\n    except:\n        return 1000.0\n\n\n# ==========================================\n# 3. RUNNER\n# ==========================================\ndef capture_universe():\n    """Re-run derivation and capture the real Universe DNA matrix."""\n    print(\"=\"*70)\n    print(\"E8 FINAL CAPTURE: RE-DERIVING UNIVERSE DNA\")\n    print(\"=\"*70)\n    print()\n    \n    # 1. INITIALIZATION\n    print(\"Phase 1: Finding N=12 Seed...\")\n    phi = (1 + np.sqrt(5)) / 2\n    h4_basis = np.array([\n        [1, 0, phi, 0, 0, 1/phi, 0, 0],\n        [0, 1, 0, phi, 1/phi, 0, 0, 0],\n        [phi, 0, -1, 0, 0, 0, 1/phi, 0],\n        [0, phi, 0, -1, 0, 0, 0, 1/phi]\n    ]).flatten()\n    \n    start_seed = None\n    for i in range(2000):\n        chaos = np.random.randn(32)\n        mix = np.random.rand() * 0.6 + 0.2\n        seed = h4_basis * (1 - mix) + chaos * mix\n        n, _ = get_topology(seed)\n        if n == 12:\n            start_seed = seed\n            print(f\"  -> Found Seed at attempt {i}\")\n            break\n            \n    if start_seed is None:\n        print(\"Failed to find seed. Try running again.\")\n        return None\n\n    # 2. OPTIMIZATION\n    print()\n    print(\"Phase 2: Fine-Tuning to Z-Scale (0.231)...\")\n    res = scipy.optimize.minimize(\n        renormalization_loss,\n        start_seed,\n        method='Nelder-Mead',\n        options={'maxiter': 5000, 'xatol': 1e-5, 'fatol': 1e-5}\n    )\n    \n    # 3. OUTPUT\n    final_mat = res.x.reshape(4, 8)\n    q, _ = np.linalg.qr(final_mat.T)\n    ortho_matrix = q[:, :4].T\n    \n    # Check Result\n    shadows = E8_ROOTS @ ortho_matrix.T\n    lens = np.sum(shadows**2, axis=1)\n    sorted_idx = np.argsort(lens)\n    sm_roots = shadows[sorted_idx[:12]]\n    cov = np.cov(sm_roots.T)\n    evals = np.linalg.eigvalsh(cov)\n    evals = np.sort(evals)[::-1]\n    k1, k2, k3 = evals[2], evals[1], evals[0]\n    sin2 = k1 / (k1 + k2)\n    target = 0.23122\n    err = abs(sin2 - target) / target * 100\n    \n    print()\n    print(\"=\"*70)\n    print(f\"DERIVATION COMPLETE\")\n    print(\"=\"*70)\n    print()\n    print(f\"sin²θ_W = {sin2:.9f}\")\n    print(f\"Target  = {target:.9f}\")\n    print(f\"Error   = {err:.6f}%\")\n    print()\n    \n    print(\"-\"*70)\n    print(\"[COPY THIS BLOCK - THE REAL UNIVERSE DNA]\")\n    print(\"-\"*70)\n    print()\n    print(\"UNIVERSE_MATRIX = np.array([\")\n    for row in ortho_matrix:\n        print(f\"    [{', '.join([f'{x:.12f}' for x in row])}],\")\n    print(\"])\")\n    print()\n    print(\"-\"*70)\n    \n    return {\n        'ortho_matrix': ortho_matrix,\n        'sin2_theta': sin2,\n        'error_pct': err\n    }\n\n\nif __name__ == \"__main__\":\n    capture_universe()